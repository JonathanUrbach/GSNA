---
title: "Using the GSNA Package"
author: "Jonathan M. Urbach"
date: "2023-10-11"
output: rmarkdown::html_vignette
bibliography: using_the_gsna_package.bib
csl: plos-computational-biology.csl
link-citations: true
vignette: >
  %\VignetteIndexEntry{Using the GSNA Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Introduction  

Pathways analysis is a family of powerful methods that associate experimentally-derived lists of genes with known genetic signatures. Such experimental gene lists can be generated by differential expression analysis, GWAS, epigenetic studies such as ATAC-Seq, high-throughput genetic screens and other methods. The gene signatures or "gene sets", are likewise derived through a variety of approaches. Some gene signatures represent curated gene sets obtained over decades of careful experimental delineation of metabolic and signalling pathways. Others are derived by high throughput methods such as chemical or genetic perturbation, chromatin-IP, GWAS, genetic screens, or associations with disease states or chromosomal locations. Still others are derived computationally by such methods as *in silico* identification and prediction of *cis*-elements. Numerous compendia of gene sets exist (henceforth referred as gene set collections (GSC)), including GeneOntology, Reactome, KEGG Pathways, as well as larger collections that incorporate many such gene set collections and others in larger searchable databases (e.g. MSigDB).  

Pathways analysis methods such as GSEA(@subramanian_gene_2005,@mootha_pgc-1-responsive_2003), CERNO(@zyla_gene_2019), DAVID(@sherman_david_2022,@huang_systematic_2009) and others work by identifying statistical associations of ordered or unordered gene lists with genetic signatures, and returning lists of gene signatures with adjusted estimated *p*-values. A common pitfall of these methods is that the resulting lists of gene signatures may be complex and difficult to interpret. The reason for this complexity is multifold. Firstly, within GSCs which may include many thousands of gene signatures, there are frequently numerous signatures that are nested or otherwise overlap, sharing many of the same genes. This is easily understood; many of the perturbations used to generate the GSCs can activate the same or overlapping pathways. In addition, multiple separate pathways may be perturbed in a given experimental dataset. A significant challenge in pathways analysis is to determine which of numerous genetic signature "hits" from a given experimental dataset represent overlapping or distinct pathways.  

Strategies exist to address this problem. TopGO (@alexa_improved_2006) maps hits against nested gene ontology gene sets to the predefined hierarchies of GO terms, and scores gene sets within the hierarchy. However it's utility is limited to gene ontology gene sets. DAVID (@sherman_david_2022,@huang_systematic_2009) uses kappa statisics to group gene sets together, but this feature is only usable within the DAVID web application and is not presently applicable to other methods or gene sets beyond those present in DAVID's online database. The **Enrichment Map** plugin for **Cytoscape** (@merico_enrichment_2010) uses Jaccard or Szymkiewicz–Simpson coefficients as distance metrics to group gene sets together, but it does not actually divide the gene sets into clusters, and is meant primarily for GSEA data. Here, we present a general method for associatiating gene sets that (1) is modular and independent of pathways-analysis method*, (2) works with arbitrary gene sets/combinations of gene sets, (3) can generate tabular gene set associations and graphical visualisations from pathways data and (4) is accessible via an application programming interface (API). We call this method Gene Set Network Analysis (GSNA).  


# Getting Started with GSNA      

## Inputs for GSNA   

The main inputs into the standard **GSNA** workflow are:

1. a filtered pathways result set  
2. a gene set collection containing (only) the gene sets to be analyzed and  
3. a background vector of observed genes  


### Pathways Data Sets:  

Gene set network analysis (**GSNA**) is meant to be done *after* pathways analysis has been performed, as a way of simplifying interpretation of a pathways analysis results set. As such, a pathways data set is one of the main inputs for the method.  

The **GSNA** package is designed to seamlessly import data sets from multiple common pathways analysis software packages and functions, including but not limited to **GSEA**(@subramanian_gene_2005,@mootha_pgc-1-responsive_2003), **DAVID**(@sherman_david_2022,@huang_systematic_2009), and the **tmodCERNOtest()** function from the **tmod** package(@zyla_gene_2019). Pathways data sets should be in the form of a data.frame. At the very minumum, the results data sets should include a column containing gene set identifiers for the pathway "hits", a column containing a significance statistic (frequently but not always a *p*-value or *q*-value), and optimally also a descriptive title or gene set name. Sometimes the **ID** and the **Title** will be the same.  

Pathways data sets are normally filtered to include only the gene sets with significant hits, for example *p*-values below a particular value of &alpha; (typically $\alpha <= 0.05$). In the case of dual-channel GSNA analysis, the pathways dataset may be the result of a merger of two separate pathways analyses, with two sets of statistical values for comparison.

### Gene Set Collections:  

Gene set collections (GSCs) should conatain only those gene sets that are to be analyzed by GSNA, and only the gene sets that are present in the pathways data set. Generally, this includes gene set hits with significant *p*- or *q*-values. Gene set collections may be supplied in any of the three following formats:  

* A named list of character vectors in which the names are the gene set names or IDs and the contents of the vectors are gene symbols.  
* A **tmod** object as used by the **tmod** package versions up to version ‘0.46.2’.  
* A **tmodGS** object as used by the **tmod** package versions since version ‘0.50.11’.  

Typically, the GSCs used for **GSNA** are not the same as the GSCs used for the initial pathways analysis, but rather they are
subsetted from the original gene set collection to contain only the gene sets with significant hits or which are otherwise of interest.

It is important that gene set identifiers (IDs) be the same in the pathways data sets as in the gene set collections, or GSNA will not work. In some cases, it may be necessary to harmonize the gene set IDs from the pathways data sets with those used in the GSC.

### Background genes:  

The set of background genes is supplied as a character vector containing the the symbols of the genes that were observed in the original analysis performed prior to pathways analysis. If pathways analysis was performed with a differential expression gene set, then the background should be a vector of all the symbols for genes observed in the differential expression data set, regardless of whether they were differentially expressed or not.  

Gene identifiers and or symbols in the **ref.background** vector should match those in the GSC in form and capitalization. In most gene set collections, such as MSigDB, symobols are capitalized. If ENSEMBL gene IDs are used in the gene set collection, the background should be the same.    

## GSNA Standard Workflow  

A standard GSNA analysis consists of the following steps:  

1. Create a GSNA object and calculate a distance matrix based on a desired distance metric using one of the following functions: **buildGeneSetNetworkSTLF()** (calculates single tail log-Fisher values), **buildGeneSetNetworkLF()** (calculates partial log Fisher values), **buildGeneSetNetworkJaccard()** (calculates Jaccard indices), **buildGeneSetNetworkOC()** (calculates Szymkiewicz–Simpson or "overlap" coefficient), or **buildGeneSetNetworkGeneric()**.  
2. Import a pathways dataset. This is typically done using the **gsnAddPathwayData()**.  
3. Pare the network using **gsnPareNetGenericHierarchic()** or **gsnPareNetGenericToNearestNNeighbors()**. This removes lower value connections between less-closely related gene sets, retaining the connections between the most closely related gene sets.  
4. Assign subnets using **gsnAssignSubnets()**. In this step, gene sets that are connected after pairing are formally assigned and tallied (this function may be incorporated into the paring step in the future).
5. Output tabular data on the subnets using **gsnMergePathways()** or **gsnSubnetSummary()**.
6. Create graphic outputs for the output data sets using **plot.GSNData()**, **gsnPlotNetwork()**, or **gsnHierarchicalDendrogram()**.  


# A real-life example: Generating a single-channel Gene Set Network with data from CERNO    

Start by loading the library, as follows:  

```{r setup}
library(GSNA)
```

The **GSNA** package supports pathways datasets generated by GSEA, DAVID, and the CERNO method (from the **tmod** package). In addition, the **GSNA** package includes a function to perform a Fisher exact test of overrepresentation (similar to DAVID) and supports the output of that function. Other tabular pathways data types are supported by specifying the **id_col**, **stat_col**, **sig_order** arguments, and for 2-channel datasets, the **stat_col_2**, **sig_order_2** fields, or otherwise using the **gsnImportGenericPathway()** function.  

In this vignette, we will use differential expression and pathways data derived from the publically-available dataset of Bai et al.(@bai_direct_2023). In their study, transcriptomic data were derived from the treatment of mouse fibroblast type 2 cells with a chemical cocktail to induce differentiation into multiple cell types, including hepatocyte-like cells (CiHep) and keratinocyte-like cells (CiKrt).

In the sample data provided, gene expression in CiHep cells and expression in CiKrt cells are both compared to the fibroblast type 2 cell type, generating two sets of differential expression data to profile both cell type transitions. These two transitions, fibroblast 2 to CiHep and fibroblast 2 to CiKrt cells were further analyzed by performing pathways analysis using a gene set collection containing sets of genes activated or repressed dependent on particular transcription factors derived from MSigDB signatures as well as from the dorothea data set(@garcia-alonso_benchmark_2019). The main signatures observed in this dataset are repressed gene signatures, genes whose expression went down upon treatment with the chemical coctail.   

Here we are performing a single-channel GSNA analysis with gene signatures that were down in CiHep cells relative to fibrinoblast 2 cells. We start by importing the **"Bai_CiHep_DN.cerno"** CERNO results set.


```{r echo=FALSE, include=FALSE, eval=FALSE}
# This was meant to have head calls render as scrolling data tables, but the results were not optimal. I may come back to this, though.
# head <- function( x, ... ){
#   DT::datatable( utils::head( x, ... ), options = list( autoWidth = FALSE, scrollX = TRUE, digits = 4 ) )
# }

```

## Preparing and Filtering Data  

```{r}
data("Bai_CiHep_DN.cerno")
```

We can inspect the structure of this CERNO data set using the head function.


```{r}
head( Bai_CiHep_DN.cerno )
```

This CERNO result set includes a gene set ID as well as several statistical values including the **cerno**, **AUC**, **cES**, and both standard (nominal) and adjusted *p*-values. We will use the adjusted *p*-values in our analysis.  

Having loaded our CERNO data set, we also load the **"Bai_gsc.tmod"** gene set collection.

```{r}
data("Bai_gsc.tmod")
```

The gene set collection object included in with the **GSNA** package is a **tmod** class object. However, as of version 0.50.11, the **tmod** package used in this vignette uses a new version of its gene set collection object, a **tmodGS** object. If you're using version 0.50.11 of the **tmod** package, convert the **Bai_gsc.tmod** into a **tmodGS** object.

```{r}
if( utils::packageVersion( pkg = "tmod" ) >= "0.50.11" ){
  Bai_gsc.tmod <- tmod::tmod2tmodGS( Bai_gsc.tmod )
}
```

Now, we can inspect the **Bai_gsc.tmod** object to see that it is indeed a **tmod** or **tmodGS** class object, and also see how many gene sets (referred to as modules) and genes it contains:

```{r}
Bai_gsc.tmod
```

Now we can filter the **Bai_CiHep_DN.cerno** data set for gene signatures that have significant adjusted *p*-values. We will use $\alpha = 0.05$ for our significance cutoff. This filtered **CERNO** data set will be used     

```{r}
.alpha <- 0.05

Bai_CiHep_DN.cerno.sig <- subset( Bai_CiHep_DN.cerno, adj.P.Val <= .alpha )
```


The ID column in a cerno dataset contains the the ID of its respective gene set, which can then be used for subsetting a gene set collection list, or a **tmod** or **tmodGS** object.:  

```{r}
Bai_CiHep_DN.sigid <- Bai_CiHep_DN.cerno.sig$ID

Bai_CiHep_DN.sigid
```

Now, we subset the **Bai_gsc.tmod** gene set collection to obtain a collection with only significant hits using the gene set IDs as keys for the tmod object. Subsetting **tmod** or **tmodGS** objects works using the list subset operator [], where the IDs are treated as indices.  

```{r}
Bai_CiHep_DN.sig.tmod <- Bai_gsc.tmod[Bai_CiHep_DN.sigid]
Bai_CiHep_DN.sig.tmod
```


Now that we have a filtered CERNO data set and a GSC containing only significant gene sets, we need the background of observable genes in our expression set. Typically, this is obtained from the differential expression data. In the case of the Bai dataset, we have expression data in the form of a Seurat data set obtained using Seurat's **FindMarkers()** function, with gene symbols as the row names. In this data, gene symbols are in "title case", with only the first letter capitalized, but gene symbols in the gene set collection are all upper case, so we convert the genes in the Bai data set to upper case too:  

```{r}
data("Bai_CiHep_v_Fib2.de")
Bai_CiHep_genes <- toupper( rownames( Bai_CiHep_v_Fib2.de ) )
```

## Creating a Gene Set Network  

Use the **buildGeneSetNetworkSTLF()** function to create a **GSNData** object and calculate a distance matrix. This first step requires just the filtered GSC and the reference background.  

```{r}
Bai_CiHep_DN.sig.GSN <- buildGeneSetNetworkSTLF( ref.background = Bai_CiHep_genes,
                                                 geneSetCollection = Bai_CiHep_DN.sig.tmod )

Bai_CiHep_DN.sig.GSN
```

**Variations:**  

* **buildGeneSetNetworkJaccard()** can be used to create networks based on the Jaccard distance.  
* **buildGeneSetNetworkOC()** can be used to create networks based on the Szymkiewicz–Simpson overlap coefficient.  

Once we have a GSNData object containing a distance matrix, we import the pathways results data set as a data.frame. This should include an ID column and a statistical column for ordering the data by significance. Such a statistical column is generally an adjusted *p*-value. When pathways data are imported, the **id_col**, **stat_col**, and **sig_order** fields must also be set, but for known data set types (CERNO, GSEA, DAVID), defaults for these can be set automatically. NOTE: the id_col is the ID used by the gene set collection whether that is in the form of a **tmod** or **tmodGS** object, or when the gene set collection is supplied as a named list of gene set character vectors.  


```{r}
Bai_CiHep_DN.sig.GSN <- gsnAddPathwayData( object = Bai_CiHep_DN.sig.GSN,
                                           pathways_data = Bai_CiHep_DN.cerno.sig )

Bai_CiHep_DN.sig.GSN
```

The **gsnAddPathwayData()** function automatically identifies the data set as a CERNO data set, and selects **'ID'** as the identifier column (**id_col**), **'adj.P.Val'** as the statistical column (**stat_col**) to be used, and the ordering of that colum (**sig_order**) as **'loToHi'** meaning that low values are treated as most significant. This value **'loToHi'** is appropriate when *p*-values or adjusted *p*-values are used as the statistical column.  

Now, pare the network using hierarchical clustering:  

```{r}
Bai_CiHep_DN.sig.GSN <- gsnPareNetGenericHierarchic( object = Bai_CiHep_DN.sig.GSN )
```

**Variations**  

* By default, the **gsnPareNetGenericHierarchic()** applies a scaling function to the distances calculated between gene sets. In general, distance metrics for which greater values are considered closer and lesser values more distant, or which include negative values need to be transformed to allow hierarchical clustering so that the values are all positive and the smallest values correspond to the least distance. If the distances between gene sets treat low values as close (as with single tail log Fisher and standard Euclidean distances), the **gsnPareNetGenericHierarchic()** function selects **distMat2UnitNormRank()** as the matrix scaling function (**matrix_scaling_fun**). If, on the other hand, high values are *closer* (as with Jaccard and Szymkiewicz–Simpson indices), the **negDistMat2UnitNormRank()** scaling function is used. These two scaling functions are essentially the same, except that **negDistMat2UnitNormRank()** multiplies the distance matrix by $-1$ before applying **distMat2UnitNormRank()** to calculate unit normalized ranks. This default behavior gives acceptable results in most cases, but for some distance metrics, other scaling functions may be used. For example, **matrix_scaling_fun = function(x) 1 - x** could be used with Jaccard and Szymkiewicz–Simpson indices.  
* Paring can alternatively be performed by joining each node to it's nearest N neighbors using the function **gsnPareNetGenericToNearestNNeighbors()**. For **N=1** (the default), this produces similar groupings of gene sets as hierarchical paring, but for greater values of **N** the networks can be very complex. 


Once we have a pared distance matrix, we can assign subnets.  

```{r}
Bai_CiHep_DN.sig.GSN <- gsnAssignSubnets( object = Bai_CiHep_DN.sig.GSN )
```


## Outputting Subnet Data    

Once subnets have been assigned, we can output a set of them in tabular format. We use gsnMergePathways to create a table of the pathways results organized into subnets. This table includes, in addition to the pathways results, **subnet** and **subnetRank** columns.     

```{r}
Bai_CiHep_DN.sig.GSN.subnets <- gsnMergePathways(object = Bai_CiHep_DN.sig.GSN )

Bai_CiHep_DN.sig.GSN.subnets
```


Within R markdown documents, data frames can be reformated for output using the **yassifyPathways()** function. In addition to providing a better output format, the values in the ID column can be nested within links to information on the corresponding gene sets using the **url_map_list** argument. The argument takes a list containing named vectors. The vectors are named according to the ID column to be substituted with a link, and the vectors contain name-value pairs in which the names are the IDs to be substituted and the values are the corresponding link URL.

In the following code block, the structure function is used to generate the ID/URL pairs from values in the MODULES slot of the **Bai_gsc.tmod** object. Calling the **yassifyPathways()** function thereby yields a table with improved format and links to the corresponding URLs describing the gene sets in question.

```{r}
url_map_l <- list( ID = with( Bai_gsc.tmod$MODULES, structure( URL, names = ID ) ))

yassifyPathways( Bai_CiHep_DN.sig.GSN.subnets,
                 url_map_list = url_map_l )
```

Note the **url_map_list** argument results in links for the gene set IDs.  

Another, more summarized report of subnets can be obtained using **gsnSubnetSummary()**. This report groups subnets together and gives some additional statistics relating to the subnets.

NOTE: In addition to its own arguments, **yassifyPathways** can pass arguments (like **options**) to **DT::datatable()** to allow additional control of table characteristics and formatting. In the example below, the options argument is used to provide horizontal scrolling.  

```{r}
Bai_CiHep_DN.sig.GSN.subnetSummary <- gsnSubnetSummary( object = Bai_CiHep_DN.sig.GSN )

yassifyPathways( Bai_CiHep_DN.sig.GSN.subnetSummary,
                 url_map_list = url_map_l,
                 options =list( autoWidth = FALSE,
                                scrollX = TRUE
                                )
                 )
```

Try horizontally scrolling this table to see all columns.  


## Plotting the Network    

Once the gene set network has been pared and subnets assigned, the **plot.GSNData()** method (called simply as **plot()**) can be used to generate plots of GSNData objects as a circular network plot. Generting a plot directly within an R graphical enviroment can work, but for R markdown, output to an SVG file and reading the image in through **knitr::include_graphics()** often produces better results. (Work is currently underway to improve automatic setting of graphical parameters by GSNA, but currently, tweaking graphical parameters can improve rendering.)


```{r}
plot( x = Bai_CiHep_DN.sig.GSN, filename = "Bai_CiHep_DN.sig.GSN.PL.svg", width = 9, height = 7, n_col = 'N1' ) -> out

knitr::include_graphics( "Bai_CiHep_DN.sig.GSN.PL.svg" )
```

Note that the **n_col = 'N1'** argument tells the plot function to scale the size of vertices according to the values of the 'N1' column of the pathways data, which indicates the number of genes in a given gene signature.  

To generate a hierarchical dendrogram of distances between gene sets, the **gsnHierarchicalDendrogram()** function can be used.  

```{r HierarchicalDendrogram_1}

gsnHierarchicalDendrogram( object = Bai_CiHep_DN.sig.GSN,
                           width = 8,
                           height = 5,
                           file = "Bai_CiHep_DN.sig.GSN.HD.svg",
                           show.leaves = TRUE,
                           show.legend = TRUE,
                           n_col = 'N1',
                           leaf_cex_range = c(0.3,1.6) )

knitr::include_graphics( path = "Bai_CiHep_DN.sig.GSN.HD.svg" )

```


On the basis of this output, it could be concluded that there are 6 subnets or clusters of gene signatures that are downregulated upon chemical induction of CiHep cells from fibroblast2 cells, with subnet 1 being the most significant, and within that, the [M30131 Psmb5](https://www.gsea-msigdb.org/gsea/msigdb/cards/PSMB5_TARGET_GENES) signature being particularly strong.  

**Variation:** A hierarchical dendrogram with a circular geometry can be generated with **gsnHierarchicalDendrogram()** using the **geometry = 'circular'** argument.  


# Generating a 2-channel Gene Set Network with CERNO data   

Two channel gene set networks are useful for comparing differential pathway activation or repression between conditions, treatments or transitions between cell types. This mainly applies to cases where two distinct cellular states are derived from a single reference state or cell type. In the Bai data set, the fibroblast 2 cellular subset differentiates into hepatocyte-like (CiHep), keratinocyte-like (CiKrt) and several other cell types upon chemical induction. In an analysis of this data set, comparisons can be made between the transition from the fibroblast 2 cell type to both the CiHep and CiKrt induced cell types. 

A 2-channel Gene Set Network workflow is very similar to a single channel workflow. The main difference is that two parallel significance statistics are used in the pathways dataset instead of a single significance statistic. These two significance statistics are derived from the two pathways datasets being compared. Subsequent steps for the analysis are nearly the same.  



## Merging Bai_CiHep_DN.cerno and Bai_CiKrt_DN.cerno

The 2-channel workflow begins with the merging of the two unfiltered parallel pathways data sets. Importantly, by "unfiltered", we mean that the two pathways data sets should conatain scores and *p*-values for all the gene sets in the gene set collection. For CERNO, such complete unfiltered result sets may be obtained by including the argument **qval = 1.1** when calling the **tmod** package's **tmodCERNOtest()** function. Using unfiltered pathways results sets allows us to generate a merged data set that includes gene signatures that are significant in either one or both of the two pathways results sets.  

We start with two, complete unfiltered data sets containing all the CERNO results for a given GSC.  

```{r}
data( Bai_CiKrt_DN.cerno )

Bai_CiHep_v_CiKrt_DN.merge <- merge( x = Bai_CiHep_DN.cerno,
                                     y = Bai_CiKrt_DN.cerno,
                                     by = 'ID' )
```


For columns common to both CERNO datasets, the names are suffixed with .x and .y depending on which argument was used.
To clean up this data, we can delete columns not of interest and give the columns with .x and .y suffixes better names, using the rename function from the **dplyr** package:

```{r}
Bai_CiHep_v_CiKrt_DN.merge$Title.y <- NULL

Bai_CiHep_v_CiKrt_DN.merge <- dplyr::rename( .data = Bai_CiHep_v_CiKrt_DN.merge,
                                             Title = Title.x,
                                             cerno.CiHep = cerno.x,
                                             N1.CiHep = N1.x,
                                             AUC.CiHep = AUC.x,
                                             cES.CiHep = cES.x,
                                             P.Value.CiHep = P.Value.x,
                                             adj.P.Val.CiHep = adj.P.Val.x,
                                             cerno.CiKrt = cerno.y,
                                             N1.CiKrt = N1.y,
                                             AUC.CiKrt = AUC.y,
                                             cES.CiKrt = cES.y,
                                             P.Value.CiKrt = P.Value.y,
                                             adj.P.Val.CiKrt = adj.P.Val.y
                                             )

head( Bai_CiHep_v_CiKrt_DN.merge )
```



## Filtering the merged dataset  

The merged dataset must now be filtered. Typically, this is done using the R **subset()** function and keeping results that have a significant adjusted *p*-value in one or the other source datasets.

```{r}
.alpha <- 0.05

Bai_CiHep_v_CiKrt_DN.filt <- subset( Bai_CiHep_v_CiKrt_DN.merge, adj.P.Val.CiHep <= .alpha | adj.P.Val.CiKrt <= .alpha )

yassifyPathways( Bai_CiHep_v_CiKrt_DN.filt,
                 url_map_list = url_map_l,
                 options =list( autoWidth = FALSE,
                                scrollX = TRUE
                                )
                 )
```

NOTE: In the merged data, you will observe that N1.CiHep and N1.CiKrt are highly correlated, but not identical. This is because the N1 statistic in the CERNO results set is the number of genes for that module that are directly observable in the differential expression data set. In this case, background gene lists for the two data sets, **Bai_CiHep_v_Fib2.de** and **Bai_CiKrt_v_Fib2.de** are slightly different, so the N1 values from their respective pathways analyses differ slightly.  


```{r include=FALSE, results=FALSE, eval=FALSE}
# THis is a little sanity check to figure out why N1's differ between the CiHep and CiKrt CERNO results sets. N1 is not the number of genes in the module in the gene set collection, but the number of genes in the gene set collection that are represented in the differential expression dataset.

sum(toupper( rownames(Bai_CiHep_v_Fib2.de) ) %in% toupper( rownames(Bai_CiKrt_v_Fib2.de) ))

Ns_table <- data.frame( ID = names(Bai_gsc.tmod$MODULES2GENES),
                        N.CiHep = sapply( X = Bai_gsc.tmod$MODULES2GENES, FUN = function(x)sum( sum( unlist(x) %in% toupper( rownames(Bai_CiHep_v_Fib2.de) ) ) ) ) ,
                        N.CiKrt = sapply( X = Bai_gsc.tmod$MODULES2GENES, FUN = function(x)sum( sum( unlist(x) %in% toupper( rownames(Bai_CiKrt_v_Fib2.de) ) ) ) ) 
)

merge( x = Ns_table, y = Bai_CiHep_v_CiKrt_DN.merge[,c("ID", "N1.CiHep", "N1.CiKrt")], by = "ID" )

```


## Creating a GSNData Network  

First, subset the Bai_gsc.tmod object to include only the gene signatures in the filtered, merged data set.  

```{r}
Bai_CiHep_v_CiKrt_DN.sig.tmod <- Bai_gsc.tmod[ Bai_CiHep_v_CiKrt_DN.filt$ID ]

Bai_CiHep_v_CiKrt_DN.sig.tmod
```


The two differential expression data sets have largely overlapping but slightly different sets of observable genes. These two bacground gene lists should give similar, but not identical distance values when generating a gene set network. We'll use the **Bai_CiHep_genes** gene list. Using the **venn** function from the **gplots** package, we can visualize the overlap of gene sets in the CiHep vs fibroblast 2 and CiKrt vs fibroblast 2 data sets.     


```{r}
Bai_CiHep_genes <- toupper( rownames( Bai_CiHep_v_Fib2.de ) )
Bai_CiKrt_genes <- toupper( rownames( Bai_CiKrt_v_Fib2.de ) )

library( gplots )
gplots::venn( list(CiHep = Bai_CiHep_genes, CiKrt = Bai_CiKrt_genes) )
```

We now calculate gene set distances and generate a GSNData object using the **buildGeneSetNetworkSTLF()** function:   

```{r}
Bai_CiHep_v_CiKrt_DN.GSN <- GSNA::buildGeneSetNetworkSTLF( geneSetCollection = Bai_CiHep_v_CiKrt_DN.sig.tmod, ref.background = Bai_CiHep_genes )
```

Adding pathways data is a little different from before, since we will need to explicitly specify stat_col, stat_col_2, sig_order and sig_order_2.

```{r}
Bai_CiHep_v_CiKrt_DN.GSN <- gsnAddPathwayData( Bai_CiHep_v_CiKrt_DN.GSN,
                                               pathways_data = Bai_CiHep_v_CiKrt_DN.filt,
                                               stat_col = "adj.P.Val.CiHep",
                                               sig_order = "loToHi",
                                               stat_col_2 = "adj.P.Val.CiKrt",
                                               sig_order_2 = "loToHi" )
```

Lets take a quick look at the GSNData object:  

```{r}
Bai_CiHep_v_CiKrt_DN.GSN
```

Now, lets pare the network and assign subnets:  

```{r}
Bai_CiHep_v_CiKrt_DN.GSN <- gsnPareNetGenericHierarchic( Bai_CiHep_v_CiKrt_DN.GSN )

Bai_CiHep_v_CiKrt_DN.GSN <- gsnAssignSubnets( Bai_CiHep_v_CiKrt_DN.GSN )

yassifyPathways( gsnMergePathways( Bai_CiHep_v_CiKrt_DN.GSN  ),
                 url_map_list = url_map_l,
                 options =list( autoWidth = FALSE,
                                scrollX = TRUE
                                ) )
```


Subnets can be output as a table with the **gsnSubnetSummary()** function.  

```{r}
yassifyPathways( gsnSubnetSummary( Bai_CiHep_v_CiKrt_DN.GSN  ), 
                 url_map_list = url_map_l,
                 options =list( autoWidth = FALSE,
                                scrollX = TRUE
                                ) )
```


## Plotting the 2-Channel Network  

In 2-Channel network plots, gene set nodes can be color-scaled in two dimensions, based on **stat_col** and **stat_col_2**. In the plots below, signatures significant in the  CiHep vs fibroblast 2 comparison are strongly red, whereas those significant in CiKrt vs fibroblast 2 are strongly blue. Any signatures significant for both comparisons would be purple. Note the square color legend that indicates significance for both channels.  


```{r}
gsnPlotNetwork( Bai_CiHep_v_CiKrt_DN.GSN, n_col = "N1.CiHep", filename = "Bai_CiHep_v_CiKrt_DN.GSN.NP.svg", width = 7, height = 5 )

knitr::include_graphics( "Bai_CiHep_v_CiKrt_DN.GSN.NP.svg" )
```

From this analysis, it may be concluded that about 7 subnets or clusters of related gene sets are downregulated in CiHep and CiKrt cells upon chemical induction of fibroblast 2 cells. In particular, the Psmb5 downregulation signature is strong in CiHeps (strong red), whereas the Hes2 signature (strong blue) is strongest in CiKrt cells.  


**Variation:** When available in the pathways data, an alternative statistic can be used to color gene sets in a gene set network. Here, we're specifying **stat_col = 'AUC.CiHep'**, suppressing the previously set value of the second statistical column with **stat_col_2 = NA** and specifying a custom set of vertex colors used to represent the AUC values, such that the color scale goes from dark blue to white.     


```{r NetworkPlot_AUC}

gsnPlotNetwork( object = Bai_CiHep_v_CiKrt_DN.GSN,
                width = 8,
                height = 5,
                file = "Bai_CiHep_v_CiKrt_DN.GSN.NP_AUC.svg",
                show.legend = TRUE,
                n_col = "N1.CiHep",
                stat_col = 'AUC.CiHep',
                sig_order = 'hiToLo',
                stat_col_2 = NA,
                vertex_colors = c('darkblue', 'blue', '#9999FF',  '#DDDDFF', 'white' )
)

knitr::include_graphics( path = "Bai_CiHep_v_CiKrt_DN.GSN.NP_AUC.svg" )

```


A hierarchical dendrogram is also revealing. This time, we'll generate a circular hierarchical dendrogram by including the argument **geometry = 'circular'**:  

```{r}
gsnHierarchicalDendrogram( Bai_CiHep_v_CiKrt_DN.GSN,
                           n_col = "N1.CiHep",
                           filename = "Bai_CiHep_v_CiKrt_DN.GSN.HD.svg",
                           width = 7,
                           height = 5,
                           show.leaves = TRUE,
                           geometry = 'circular' )

knitr::include_graphics( "Bai_CiHep_v_CiKrt_DN.GSN.HD.svg" )
```


Hierarchical dendrograms display relationships between all the gene sets, whereas the circular network plot show just gene sets connected to their nearest neighbors within subnet, but not connections between the subnets. Otherwise, the data shown are similar, and the **gsnHierarchicalDendrogram()** function posesses many of the same capabilities as the network plot function, including the ability to specify an alternative statistical columns for leaf coloration and the ability to vary the size of gene set leaves by gene set size.  


# Using GSNA with GSEA Data  

GSEA is a popular pathways analysis program available from  [https://www.gsea-msigdb.org/gsea/index.jsp](https://www.gsea-msigdb.org/gsea/index.jsp)(@subramanian_gene_2005,@mootha_pgc-1-responsive_2003).  Users supply a GSC and either a normalized gene expression matrix and a list of sample phenotypes or a "pre-ranked" ordered list of genes; GSEA then uses those data to calculate an enrichment score (**ES**) statistic and a normalized enrichment score (**NES**). Positive **ES** and **NES** statistics indicate a positive association of gene sets with the data, e.g. gene sets that showed activation or increased expression in a data set or tended toward the beginning of the gene list, whereas negative **ES** and **NES** scores indicate a negative association. Using a permutation test, GSEA then estimates p-values (NOM *p*-val), false discovery rates (FDR *q*-val), and familywise error rates (FWER *q*-val) for each gene set association. Because GSEA uses permutation tests to determine *p*-values, *p*-values cannot reliably be measured below $p = 1/ [# permuations]$. As a consequence, many highly significant associations will have *p*-values estimated to be 0.  

When running GSEA, users may specify an output directory; otherwise the data are saved to a subdirectory named "~/gsea_home/output/[date]" within the user's home directory. Results files are stored in these results directories with names along the lines of "gsea_report_for_Pheno1_1698209272006.tsv", with "gsea_report_for_" as a prefix, the phenotype being compared, and lastly, numbers + ".tsv" as the suffix. Results files are generally present in pairs appropriate for a given comparison, For a pheno1_versus_pheno2 comparison, there could be a file "gsea_report_for_Pheno1_1698209272006.tsv" with positive **ES** and **NES** values, and "gsea_report_for_Pheno2_1698209272006.tsv" file with negative **ES** and **NES** values. Such output files can be suitable as inputs for GSNA. Since *p*-values (and *q*-values) may not be accurately estimated below $p = 1/[# permuations]$, **NES** or **ES** statistics may be more suitable for use as the primary statistic used for GSEA. Since GSEA separates *UP* gene sets and *DOWN* gene sets into two different output files, these may be combined for a comprehensive analysis of activated and repressed gene sets.

The following figure illustrates the relationship between GSEA's **NES** and nominal *p*-value statistics for a concatenated data set derived from a comparison of CiHep versus fibroblast 2 cells. Non-significant and significant results assessed on the basis of FDR *q*-values are indicated by crosses and solid circles, respectively.    

```{r, echo=FALSE}
data( "Bai_CiHep_dorothea_DN.Gsea" )
data( "Bai_CiHep_dorothea_UP.Gsea" )

Bai_CiHep_dorothea_UD.Gsea <- rbind( Bai_CiHep_dorothea_UP.Gsea, Bai_CiHep_dorothea_DN.Gsea )
Bai_CiHep_dorothea_UD.Gsea$`Activated In` <- sapply( X = Bai_CiHep_dorothea_UD.Gsea$NES, function(x) ifelse( x > 0, "CiHep", "Fibroblast2" ) )
Bai_CiHep_dorothea_UD.Gsea$`FDR q-val<=0.05` <- ifelse( Bai_CiHep_dorothea_UD.Gsea$`FDR q-val` <= 0.05, "significant", "not significant" )

ggplot2::ggplot( data = Bai_CiHep_dorothea_UD.Gsea,
                 mapping = ggplot2::aes( x = NES,
                                         y = `NOM p-val`,
                                         color = `Activated In`,
                                         shape = `FDR q-val<=0.05`,
                                         text = paste0( 'Gene Set Name: ',NAME ) ) ) +
  ggplot2::geom_point() +
  ggplot2::scale_shape_manual( values = c(3, 19)) +
  ggplot2::scale_color_manual( values = c( "red", "blue" ) ) 


rm( Bai_CiHep_dorothea_UD.Gsea )
```

Note that **NES** values are discontinuous, but have an approximately symmetrical relationship with the corresponding *p*-values. Note that only values at the extremes of **NES** have significant FDR *q*-values.

The primary statistic, **stat_col** determines how subnets are assigned, with the most significant results being assigned first. In the case of *p*-values and *q*-values, the lowest numerical values are most significant, and hence we specify **sig_order = 'loToHi'**. In the case of **NES** and **ES**, the most significant values are in the extremes. (To do: add support for abs('hiToLo') for this case.) 

In this current example, we will use the FDR *p*-value as the primary statistic for assigning subnet membership, but use **NES** as the statistic for graphical outputs.  


## Generating a single-channel Gene Set Network with GSEA data   

Using GSEA data with GSNA is straightforward and similar to using it with CERNO data. For this example, start by loading the **Bai_CiHep_dorothea_DN.Gsea** and **Bai_CiHep_dorothea_UP.Gsea** data sets into memory, along with an expression matrix containing gene symbols in the rows, **Bai_empty_expr_mat**. (For the sake of illustrating the process, **Bai_empty_expr_mat** is an empty expression matrix containing no columns of data, just the gene symbols in the rows.)  


```{r}
data( "Bai_CiHep_dorothea_DN.Gsea" )
data( "Bai_CiHep_dorothea_UP.Gsea" )
data( "Bai_empty_expr_mat" )
```

These two data sets are saved as data objects within the **GSNA** package, but for your own data, you could load them into memory with such commands as this:

```
Bai_CiHep_dorothea_UP.Gsea <- read.table( file = file.path( gsea_outputs_dir,
                                                            "gsea_report_for_CiHep_1698197511726.tsv" ),
                                          header = TRUE,
                                          check.names = FALSE,
                                          sep = "\t" )

Bai_CiHep_dorothea_DN.Gsea <- read.table( file = file.path( gsea_outputs_dir,
                                                            "gsea_report_for_Fibroblast2_1698197511726.tsv" ),
                                          header = TRUE,
                                          check.names = FALSE,
                                          sep = "\t" )

```

These two data sets can be considered together. To do so, we'll use the rbind function to combine the two data sets into one.  


```{r}
Bai_CiHep_dorothea_UD.Gsea <- rbind( Bai_CiHep_dorothea_UP.Gsea, Bai_CiHep_dorothea_DN.Gsea )

yassifyPathways( Bai_CiHep_dorothea_UD.Gsea,
                 options = list( autoWidth = FALSE,
                                 scrollX = TRUE ),
                 n = 6   # <= this argument tells the function to just show the first 6 results
                 )
```

Note the empty 12th column present in the imported GSEA tsv output table, plus the **`GS DETAILS`** without useful information and the **`GS<br> follow link to MSigDB`** that duplicates the **NAME** column. We can clean up this data somewhat by removing these:  

```{r}
Bai_CiHep_dorothea_UD.Gsea[[12]] <- NULL
Bai_CiHep_dorothea_UD.Gsea$`GS DETAILS` <- NULL
Bai_CiHep_dorothea_UD.Gsea$`GS<br> follow link to MSigDB` <- NULL

```


We will filter the data sets using the subset command with $`FDR q-val` <= 0.05$:    

```{r}
Bai_CiHep_dorothea_UD.FILT <- subset( Bai_CiHep_dorothea_UD.Gsea, `FDR q-val` <= 0.05 )
```


Using this filtered GSEA dataset, we will now generate a GSC that contains only the gene sets of interest, i.e. those with significant estimated FDR values. Here we use the gene set names from the GSEA result set as indices for subsetting the Bai_gsc.tmod object.  


```{r}
Bai_gsc.tmod.gsea <- Bai_gsc.tmod[ Bai_CiHep_dorothea_UD.FILT$NAME ]

Bai_gsc.tmod.gsea
```

**NOTE:** For this step to work properly, the gene set names in the GSEA data set must match those in the GSC. However, there are cases when the name used in the GSEA data set does not match those used as indices in the GSC. This happens particularly when using a GSEA dataset is used with a **tmod** object generated by importing an MSigDB XML database using the **tmod::tmodImportMSigDB()** function. In this case, the **tmod** object generated uses `systematic names` as the key, e.g. 'M22163' whereas the GSEA data set contains `gene set names` (e.g. 'GO_MITOCHONDRIAL_RNA_CATABOLIC_PROCESS').  In such a situation, it is advisable to add a column in the **GSEA** data set containing the `systematic name` or alternatively, convert the names in **tmod** object to appropriate gene set names (which can be more difficult than the first option).    

(TO DO: Add a note about fixing gene set names.)  
 
Once the GSC has been subsetted, we can obtain a background gene list from the gene expression matrix. Here we extract the background gene set from **Bai_empty_expr_mat**, making sure to convert the gene symbols into upper case.

```{r}
Bai_background_genes <- toupper( rownames( Bai_empty_expr_mat ) )
```

Now we can calculate a Jaccard distance matrix and create a GSNData object:   

```{r}
Bai_CiHep_dorothea_UD.GSN <- buildGeneSetNetworkJaccard( ref.background = Bai_background_genes,
                                                         geneSetCollection = Bai_gsc.tmod.gsea )
```

Next, we import the filtered pathways data set. Since we are opting to use 'FDR q-val' as our primary statistic with **sig_order = 'loToHi'**, we can specify that in this command.

The 'sig_order' parameter specifies the order in which subnet membership is assigned, and therefore the order that they are reported. It also specifies how they will be colored for output plots, though users can override the automatic plot coloring behavior. In our case, since the NES values are mostly negative in our dataset, we will assign **sig_order = 'loToHi'**.

```{r}
Bai_CiHep_dorothea_UC.GSN <- gsnAddPathwayData( object = Bai_CiHep_dorothea_UD.GSN,
                                                pathways_data = Bai_CiHep_dorothea_UD.FILT,
                                                stat_col = 'FDR q-val',
                                                sig_order = 'loToHi' )

Bai_CiHep_dorothea_UC.GSN
```

Please ignore any warning about the missing **GS DETAILS** field, which we removed prior.  

**NOTE:** For *p*-values and *q*-values, use sig_order = 'loToHi'. For data in which high or extreme values are most significant, use 'hiToLo'. (We may in the future add an option to specifically handle zero-centered extreme values properly in the future as 'absHiToLo'.)  

Next, we pare the network and assign subnets. We'll use nearest single neighbor pairing for this example, with the **gsnPareNetGenericToNearestNNeighbors()** function. Among the factors that determine the granularity of the clustering into subnets are the **cutoff** and **extreme** parameters. The **cutoff** parameter specifies the maximal or minimal value of calculated distance for which gene-set groupings can be joined into subnets. More *distant* connections are removed. For distance metrics like **stlf** (single tailed log Fisher), **lf**, etc., for which lower values are considered *closer*, **extreme = 'min'**, hence **cutoff** is treated as the maximal distance for which gene sets may be joined in a subnet. For distance metrics such as Jaccard index or the Szymkiewicz–Simpson overlap coefficient, for which greater values are *closer*, **extreme = 'max'**, and **cutoff** is treated as the *minimal* value of distance for which gene sets may be joined into a subnet.  

We have had good results when the **cutoff** is selected to retain $1 \over 4$ to $1 \over 2$ of distances in the distance matrix. We use the **gsnDistanceHistogram()** function with the argument **stat = 'cumulative'** specified to examine the distribution of distances in the raw distance matrix.  

```{r}
gsnDistanceHistogram( Bai_CiHep_dorothea_UC.GSN, stat = "cumulative" )
```

We see that roughly half of the Jaccard values in the data set are 0, so we select a value just above that, 0.02, which retains approximately $1 \over 4$ of the distances.   


```{r}
Bai_CiHep_dorothea_UC.GSN <- gsnPareNetGenericToNearestNNeighbors( object = Bai_CiHep_dorothea_UC.GSN,
                                                                   N = 1,
                                                                   keepOrphans = TRUE, cutoff = 0.02 )

Bai_CiHep_dorothea_UC.GSN <- gsnAssignSubnets( object = Bai_CiHep_dorothea_UC.GSN )
```


## Outputting Results Sets  

Finally we can generate reports for our subnets. With **gsnMergePathways()**, the results will be ordered on the basis of how subnets were assigned. Here we will do it in two steps. The **Bai_CiHep_dorothea_UC.subnets** data.frame can be manipulated or reordered as desired, for example with **dplyr::arrange**, or saved to a file for later processing.

```{r}
Bai_CiHep_dorothea_UC.subnets <- gsnMergePathways( object = Bai_CiHep_dorothea_UC.GSN )

yassifyPathways( Bai_CiHep_dorothea_UC.subnets,
                 options =list( autoWidth = FALSE,
                                scrollX = TRUE
                                ) )
```

An interpretation of this result set would be that the GSEA pathways results break down into an estimated 16 subnet groupings. These groupings are approximate, and dependent on parameters used for **gsnPareNetGenericToNearestNNeighbors()**, particularly the **cutoff** parameter which specifies the minimal or maximal value of the distance parameter for which gene sets can be grouped in a network, depending on the distance metric being used. Within each subnet, the higher significance gene sets may indicate biologically significant associations. In this example GSEA analysis, we used a database with gene sets directed and repressed by particular transcription factors, so in the Bai data, these transcription factors may be considered candidates for mediating the differentiation of fibroblast 2 cells into CiHeps, or hepatocyte like cells. In particular the gene signatures of AR, ELF3, FOXK2, KLF5, KDM5B are downregulated in CiHeps, whereas those of ETV4 & SPI1 are elevated.


We can now use the **gsnSubnetSummary()** function to generate a concise table of the subnets with summary statistics. By default, the summary statisics calculated are harmonic means and min or max values depending on the value of **sig_order**. These are generally appropriate for combining and sumarizing *p*-values and *q*-values, but may not be appropriate for a value such as NES. Here we will specifically specify that the mean and maximal (**max**) NES values should be calculated instead.  


```{r}
yassifyPathways( gsnSubnetSummary( object = Bai_CiHep_dorothea_UC.GSN, summary_statistics = c("mean", "max")  ),
                 options =list( autoWidth = FALSE,
                                scrollX = TRUE
                 ) )

```


To calculate instead the default statistics using `FDR q-val`, we can simply specify that as an argument to gsnSubnetSummary:  

```{r}
yassifyPathways( gsnSubnetSummary( object = Bai_CiHep_dorothea_UC.GSN,
                                   stat_col = 'FDR q-val',
                                   sig_order = 'loToHi'  ),
                 options =list( autoWidth = FALSE,
                                scrollX = TRUE
                 ) )

```

## Ploting the Network  

We now plot the network using the default stat_col parameter, **`FDR q-val`**:   

```{r}
gsnPlotNetwork( object = Bai_CiHep_dorothea_UC.GSN,
                n_col = "SIZE",
                height = 7,
                width = 9,
                filename = "Bai_CiHep_dorothea_UC.GSN.DEF.NP.svg" )

knitr::include_graphics( "Bai_CiHep_dorothea_UC.GSN.DEF.NP.svg" )

```

Now, we can plot the network, coloring nodes on the basis of **NES** values, with a custom blue, white, red color scale to color the extreme values. We also use **sig_transform_function = 'identity'** to suppress the default log-transformation of the significance statistic.  

```{r}
gsnPlotNetwork( object = Bai_CiHep_dorothea_UC.GSN,
                n_col = "SIZE",
                stat_col = 'NES',
                sig_order = 'hiToLo',
                sig_transform_function = identity,
                vertex_colors = c("blue", "white", "red"), 
                height = 7,
                width = 9,
                filename = "Bai_CiHep_dorothea_UC.GSN.NES.NP.svg" )

knitr::include_graphics( "Bai_CiHep_dorothea_UC.GSN.NES.NP.svg" )

```

To obtain a hierarchical dendrogram, the network must be pared using the **gsnPareNetGenericHierarchic()** function. However, this network was pared using nearest neighbor paring. To generate a hierarchical dendrogram, the **gsnPareNetGenericHierarchic()** functin may be called on the fly, as a nested argument to **gsnHierarchicalDendrogram()**. This is useful if you wish to see how similar the gene set associations are between the two methods.  


```{r}
gsnHierarchicalDendrogram( object = gsnAssignSubnets(gsnPareNetGenericHierarchic( Bai_CiHep_dorothea_UC.GSN )),
                           stat_col = 'NES',
                           sig_order = 'hiToLo',
                           n_col = "SIZE",
                           sig_transform_function = identity,
                           show.leaves = TRUE,
                           show.legend = TRUE,
                           leaf_colors =  c("blue", "white", "red"),
                           width = 7,
                           height = 11,
                           filename = "Bai_CiHep_dorothea_UC.GSN.HD.svg",
                           lab.cex = 0.8 )

knitr::include_graphics( "Bai_CiHep_dorothea_UC.GSN.HD.svg" )
 
```

One interpretation of these results are that changes in expression associated with the differentiation of fibroblast 2 cells into CiHep cells upon chemical induction are characterized mainly by repression of numerous transcriptional programs such as those directed by the Myc, Ar, KLF5 and TP53 transcription factors, and activation of Spi1 and Etv4. 


# References

<div id="refs"></div>




