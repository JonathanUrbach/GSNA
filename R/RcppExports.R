# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

lfisher_cpp <- function(a, b, c, d, e_precision = 12.0, alternative = 1L) {
    .Call(`_GSNA_lfisher_cpp`, a, b, c, d, e_precision, alternative)
}

gsIntersect <- function(gs1, gs2) {
    .Call(`_GSNA_gsIntersect`, gs1, gs2)
}

gsIntersectCounts <- function(gs1, gs2, bg_size) {
    .Call(`_GSNA_gsIntersectCounts`, gs1, gs2, bg_size)
}

gsnFilterGeneSetCollectionList <- function(bg, geneSetCollection) {
    .Call(`_GSNA_gsnFilterGeneSetCollectionList`, bg, geneSetCollection)
}

gsnORAtest_cpp <- function(l, bg, geneSetCollection) {
    .Call(`_GSNA_gsnORAtest_cpp`, l, bg, geneSetCollection)
}

#' scoreLFMatrix_C
#'
#' @description Takes a presence/absence matrix with genes as the rows and modules as columns and calculates
#' a matrix of log-transformed Fisher *p*-values.
#'
#' @usage \code{scoreLFMatrix_C( geneSetCollection_m,
#'                        e_precision = 12,
#'                        alternative = 1 )
#' }
#'
#'
#' @param geneSetCollection_m (required) This is a logical matrix conataining gene sets/modules as columns, genes as
#' rows, and boolean values corresponding to the presence of those genes in the corresponding modules.
#'
#' @param e_precision (optional, default 12) Numeric to control the precision of the log p-value calculated.
#' Due to precision limits inherant in C++ double precision numbers, log p-values for which the corresponding
#' untransformed p-values differ by more than a certain magnitude cannot effectively be added. This feature
#' was introduced as a way to accelerate summation of p-values so as to allow summation to be cut off
#' when the acceptable level of precision had been reached, but it was found that it also seems to prevent
#' artifacts caused by numerical underruns.
#'
#' @param alternative (optional, default 1) An interger value specifying one of 4 alternative p-value calculations
#' where \code{1} specifies single, upper tail log Fisher p-value, \code{2} signifies single, lower-tail Fisher
#' p-value, \code{3} signifies 2-tailed Fisher p-value, and \code{4} signifies partial Fisher p-value (see below).
#'
#' @return A numerical matrix containing the specified log Fisher *p*-values for all non-self pairs. Values on the
#' diagonal (which would correspond to self-self comparison *p*-values) are NA. The \code{'lower_is_closer'}
#' attribute on the matrix is set to \code{TRUE}, except in the case of \code{alternative=2} where it is set
#' to \code{FALSE}.
#'
#' @export
#'
#' @details
#'
#' Fisher *p*-values have long been used to assess the statistical significance of over- or underrepresentation
#' of a component of a mixture to assess whether a sample is drawn from a particular mixture. The test has also
#' long been used in pathways analysis as a way to assess whether an experimentally derived list of genes
#' contains a statistical overrepresentation of genes from predefined gene sets or modules. Such experimental gene
#' lists may include differentially expressed genes from a transcriptomic experiment, genes posessing promoters
#' with differential chromatin accessibility from an ATACSeq experiments, genes that were positive in screens of
#' mutants, genes that were identified from GWAS experiments, and genes from other analyses. Likewise, the gene
#' sets or modules are generally drawn from databases of experimentally characterized pathways, sets of genes
#' over- or under-expressed in particular conditions, or associated with particular biological processes,
#' chromosome regions, etc.
#'
#' In the case of GSNA, we use the Fisher test to assess the overlap of genes not between an experimentally
#' derived gene list and predefined gene sets from a database, but between the predefined gene sets themselves
#' given their observability in a particular experiment.
#'
#' # Implementation
#'
#' We use the Fisher test to assess the statistical significance of the overlap of two gene sets. For our purposes
#' the test determines whether two gene sets share a greater (or in some cases less) than expected number of common
#' members, assuming a null hypothesis of random membership. The two sets need not necessarily be of the same size,
#' but are for the purposes of the test assumed to have set sizes.
#'
#' Consider a 2x2 contingency matrix of the following form:
#'
#'\preformatted{
#'                     | a  b |
#'                     | c  d |
#'}
#'
#' Given a background of observable genes and two gene sets, *i* and *j* that may overlap, this contingincy
#' table is used to represent four numbers:
#'
#' \itemize{
#'   \item{*a*: the number of genes observed in the background but not in *i* or *j*}
#'   \item{*b*: the number of observed genes in *i* but not *j*}
#'   \item{*c*: the number of observed genes in *j* but not *i* and}
#'   \item{*d*: the number of observed genes in both *j* and *i*, i.e. the overlap.}
#' }
#'
#' The *partial*-Fisher *p*-value, signifying the likelihood of that particular contingency
#' table is given by:
#'
#'\preformatted{
#'               (a + b)! (c + d)! (a + c)! (b + d)!
#'          p = -------------------------------------
#'                     a! b! c! d! (a+b+c+d)!
#'}
#'
#' This partial *p*-value is what is returned in the distance matrix when the artgument \code{alternative = 4}
#' and it is less than, though tracks closely with, the two-tailed p-value, in most cases.
#'
#' The actual single- and two-tailed *p*-values are derived from this number by summation, keeping the sum of
#' each row and column of the 2x2 contingency matrix constant, as per the assumptions of the Fisher test.
#' For the single-tailed alternative representing the upper-tail 'greater-than' expected overlap of the two gene
#' sets (\code{alternative = 1}), the terms start with *d* as the observed number of shared members between set
#' *i* and set *j*. Then *d* is incremented toward the maximal number possible shared genes (the lesser of the
#' number of genes in sets *i* and *j*). *a*, *b*, and *c* adjusted accordingly to keep constant row and
#' column sums, and the partial *p*-values are thus summed.
#'
#' For the lower-tail ('less-than') alternative (\code{alternative = 2}), the summation starts with *d* as the
#' number of shared members of sets between *i* and *j*, (as with the upper-tail calculation) but then decrements
#' that to 0.
#'
#' For the 2-tailed alternative, the function sums all the terms with values equal to or less than the the
#' partial *p*-value defined above.
#'
#' All calculations are done on log-transformed values to avoid numerical underruns:
#'
#'\preformatted{
#'  ln(p) = ln(( a + b )!) + ln(( c + d )!) +
#'          ln(( a + c )!) + ln(( b + d )!) -
#'          ln(a!) - ln(b!) - ln(c!) - ln(d!) -
#'          ln(( a + b + c + d )!)
#'}
#'
#' Since log-transformed *p*-values cannot be directly added, the so-called log-sum-exponential trick is used to
#' combine them.
#'
#'
#' @examples
#' \dontrun{
#' library( GSNA )
#' LFMatrix <- scoreLFMatrix_C( PresenceAbsMatrix )
#'}
#'
#' @seealso \code{\link{buildGeneSetNetworkLFFast}}, \code{\link{scoreSTLFMatrix}}, \code{\link{scoreJaccardMatrix_C}}
#'
scoreLFMatrix_C <- function(geneSetCollection_m, e_precision = NULL, alternative = as.integer( c( 1 ))) {
    .Call(`_GSNA_scoreLFMatrix_C`, geneSetCollection_m, e_precision, alternative)
}

#' scoreJaccardMatrix_C
#'
#' @description Takes a presence/absence matrix with genes as the rows and modules as columns and calculates
#' a matrix of Jaccard index values.
#'
#' @param geneSetCollection_m
#'
#' @return This function returns a matrix of Jaccard index values between gene modules. Values on the diagonal
#' corresponding to self-Jaccard indices are returned as NA.
#'
#' @export
#'
#' @details The Jaccard index J for two sets A and B is defined as:
#'
#' \preformatted{
#'                     | A ∩ B |
#'           J(A,B) = -----------
#'                     | A ∪ B |
#' }
#'
#'
#' @examples
#' \dontrun{
#' library( GSNA )
#' jaccardMatrix <- scoreJaccardMatrix_C( PresenceAbsMatrix )
#' }
#'
#' @seealso \code{\link{buildGeneSetNetworkJaccard}}, \code{\link{scoreLFMatrix_C}}, \code{\link{scoreSTLFMatrix}}
#'
scoreJaccardMatrix_C <- function(geneSetCollection_m) {
    .Call(`_GSNA_scoreJaccardMatrix_C`, geneSetCollection_m)
}

